export const codeLines = [
  'from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks',
  'from sqlalchemy.orm import Session, sessionmaker',
  'from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine',
  'from typing import Dict, Any, Optional, List, Union, Callable',
  'import stripe, asyncio, hashlib, hmac, time',
  'from contextlib import asynccontextmanager',
  'from dataclasses import dataclass, field',
  'from enum import Enum',
  'import logging, redis.asyncio as redis',
  'from decimal import Decimal, ROUND_HALF_UP',
  '',
  'logger = logging.getLogger(__name__)',
  '',
  'class TransactionState(Enum):',
  '    INITIATED = "initiated"',
  '    PROCESSING = "processing"',
  '    COMPLETED = "completed"',
  '    FAILED = "failed"',
  '    COMPENSATING = "compensating"',
  '',
  '@dataclass',
  'class SagaStep:',
  '    action: Callable',
  '    compensation: Callable',
  '    timeout: float = 30.0',
  '    retries: int = 3',
  '    executed: bool = field(default=False)',
  '',
  'class CircuitBreakerState(Enum):',
  '    CLOSED = "closed"',
  '    OPEN = "open"',
  '    HALF_OPEN = "half_open"',
  '',
  'class CircuitBreaker:',
  '    def __init__(self, failure_threshold: int = 5, recovery_timeout: float = 60.0):',
  '        self.failure_threshold = failure_threshold',
  '        self.recovery_timeout = recovery_timeout',
  '        self.failure_count = 0',
  '        self.last_failure_time = None',
  '        self.state = CircuitBreakerState.CLOSED',
  '',
  '    async def call(self, func: Callable, *args, **kwargs):',
  '        if self.state == CircuitBreakerState.OPEN:',
  '            if time.time() - self.last_failure_time > self.recovery_timeout:',
  '                self.state = CircuitBreakerState.HALF_OPEN',
  '            else:',
  '                raise HTTPException(503, "Service temporarily unavailable")',
  '',
  '        try:',
  '            result = await func(*args, **kwargs)',
  '            if self.state == CircuitBreakerState.HALF_OPEN:',
  '                self.state = CircuitBreakerState.CLOSED',
  '                self.failure_count = 0',
  '            return result',
  '        except Exception as e:',
  '            self.failure_count += 1',
  '            self.last_failure_time = time.time()',
  '            if self.failure_count >= self.failure_threshold:',
  '                self.state = CircuitBreakerState.OPEN',
  '            raise e',
  '',
  'class EventStore:',
  '    def __init__(self, redis_client: redis.Redis):',
  '        self.redis = redis_client',
  '',
  '    async def append_event(self, stream_id: str, event_type: str, data: Dict[str, Any]):',
  '        event = {"type": event_type, "data": data, "timestamp": time.time()}',
  '        await self.redis.xadd(f"stream:{stream_id}", event)',
  '',
  '    async def get_events(self, stream_id: str, from_id: str = "0") -> List[Dict]:',
  '        events = await self.redis.xrange(f"stream:{stream_id}", min=from_id)',
  '        return [{"id": event_id, **fields} for event_id, fields in events]',
  '',
  'class PaymentSaga:',
  '    def __init__(self, event_store: EventStore, stripe_client):',
  '        self.event_store = event_store',
  '        self.stripe = stripe_client',
  '        self.steps: List[SagaStep] = []',
  '',
  '    async def reserve_funds(self, payment_id: str, amount: Decimal) -> Dict:',
  '        await self.event_store.append_event(payment_id, "funds_reservation_started", {"amount": str(amount)})',
  '        # Complex fund reservation logic with multi-currency support',
  '        reserve_result = await self._execute_with_retry(self._reserve_funds_impl, payment_id, amount)',
  '        await self.event_store.append_event(payment_id, "funds_reserved", reserve_result)',
  '        return reserve_result',
  '',
  '    async def _reserve_funds_impl(self, payment_id: str, amount: Decimal) -> Dict:',
  '        # Simulate complex fund reservation with currency conversion',
  '        conversion_rate = await self._get_conversion_rate("USD", "EUR")',
  '        reserved_amount = amount * Decimal(str(conversion_rate))',
  '        return {"payment_id": payment_id, "reserved": str(reserved_amount), "rate": conversion_rate}',
  '',
  '    async def _get_conversion_rate(self, from_currency: str, to_currency: str) -> float:',
  '        # Mock complex currency conversion with rate caching',
  '        cache_key = f"rate:{from_currency}:{to_currency}"',
  '        cached_rate = await self.event_store.redis.get(cache_key)',
  '        if cached_rate:',
  '            return float(cached_rate)',
  '        rate = 0.85  # Mock rate',
  '        await self.event_store.redis.setex(cache_key, 300, str(rate))',
  '        return rate',
  '',
  '    async def _execute_with_retry(self, func: Callable, *args, max_retries: int = 3) -> Any:',
  '        for attempt in range(max_retries):',
  '            try:',
  '                return await func(*args)',
  '            except Exception as e:',
  '                if attempt == max_retries - 1:',
  '                    raise e',
  '                await asyncio.sleep(2 ** attempt)',
  '',
  'class PaymentService:',
  '    def __init__(self, db: AsyncSession, redis_client: redis.Redis):',
  '        self.db = db',
  '        self.redis = redis_client',
  '        self.stripe = stripe',
  '        self.stripe.api_key = "sk_test_..."',
  '        self.circuit_breaker = CircuitBreaker()',
  '        self.event_store = EventStore(redis_client)',
  '        self.saga = PaymentSaga(self.event_store, self.stripe)',
  '',
  '    async def process_complex_payment(self, amount: Decimal, currency: str, metadata: Dict) -> Dict:',
  '        payment_id = self._generate_payment_id()',
  '        ',
  '        try:',
  '            # Start distributed transaction saga',
  '            await self.event_store.append_event(payment_id, "payment_initiated", {',
  '                "amount": str(amount), "currency": currency, "metadata": metadata',
  '            })',
  '            ',
  '            # Step 1: Reserve funds with compensation',
  '            reserve_result = await self.saga.reserve_funds(payment_id, amount)',
  '            ',
  '            # Step 2: Create Stripe payment intent with circuit breaker',
  '            intent = await self.circuit_breaker.call(',
  '                self._create_stripe_intent, amount, currency, metadata',
  '            )',
  '            ',
  '            # Step 3: Complex fraud detection',
  '            fraud_score = await self._assess_fraud_risk(metadata, amount)',
  '            if fraud_score > 0.8:',
  '                await self._compensate_reservation(payment_id)',
  '                raise HTTPException(422, "Transaction flagged for fraud")',
  '            ',
  '            await self.event_store.append_event(payment_id, "payment_completed", {',
  '                "intent_id": intent["id"], "fraud_score": fraud_score',
  '            })',
  '            ',
  '            return {"payment_id": payment_id, "client_secret": intent["client_secret"]}',
  '            ',
  '        except Exception as e:',
  '            await self.event_store.append_event(payment_id, "payment_failed", {"error": str(e)})',
  '            await self._execute_saga_compensation(payment_id)',
  '            raise HTTPException(500, f"Payment processing failed: {str(e)}")',
  '',
  '    def _generate_payment_id(self) -> str:',
  '        return hashlib.sha256(f"{time.time()}{asyncio.current_task()}".encode()).hexdigest()[:16]',
];

export const TERMINAL_FILES = [
  {
    name: 'payment_service.py',
    language: 'python' as const,
    lines: [
      'from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks',
      'from sqlalchemy.orm import Session, sessionmaker',
      'from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine',
      'from typing import Dict, Any, Optional, List, Union, Callable',
      'import stripe, asyncio, hashlib, hmac, time',
      'from contextlib import asynccontextmanager',
      'from dataclasses import dataclass, field',
      'from enum import Enum',
      'import logging, redis.asyncio as redis',
      'from decimal import Decimal, ROUND_HALF_UP',
      '',
      'logger = logging.getLogger(__name__)',
      '',
      'class TransactionState(Enum):',
      '    INITIATED = "initiated"',
      '    PROCESSING = "processing"',
      '    COMPLETED = "completed"',
      '    FAILED = "failed"',
      '    COMPENSATING = "compensating"',
      '',
      '@dataclass',
      'class SagaStep:',
      '    action: Callable',
      '    compensation: Callable',
      '    timeout: float = 30.0',
      '    retries: int = 3',
      '    executed: bool = field(default=False)',
      '',
      'class CircuitBreakerState(Enum):',
      '    CLOSED = "closed"',
      '    OPEN = "open"',
      '    HALF_OPEN = "half_open"',
      '',
      'class CircuitBreaker:',
      '    def __init__(self, failure_threshold: int = 5, recovery_timeout: float = 60.0):',
      '        self.failure_threshold = failure_threshold',
      '        self.recovery_timeout = recovery_timeout',
      '        self.failure_count = 0',
      '        self.last_failure_time = None',
      '        self.state = CircuitBreakerState.CLOSED',
      '',
      '    async def call(self, func: Callable, *args, **kwargs):',
      '        if self.state == CircuitBreakerState.OPEN:',
      '            if time.time() - self.last_failure_time > self.recovery_timeout:',
      '                self.state = CircuitBreakerState.HALF_OPEN',
      '            else:',
      '                raise HTTPException(503, "Service temporarily unavailable")',
      '',
      '        try:',
      '            result = await func(*args, **kwargs)',
      '            if self.state == CircuitBreakerState.HALF_OPEN:',
      '                self.state = CircuitBreakerState.CLOSED',
      '                self.failure_count = 0',
      '            return result',
      '        except Exception as e:',
      '            self.failure_count += 1',
      '            self.last_failure_time = time.time()',
      '            if self.failure_count >= self.failure_threshold:',
      '                self.state = CircuitBreakerState.OPEN',
      '            raise e',
      '',
      'class EventStore:',
      '    def __init__(self, redis_client: redis.Redis):',
      '        self.redis = redis_client',
      '',
      '    async def append_event(self, stream_id: str, event_type: str, data: Dict[str, Any]):',
      '        event = {"type": event_type, "data": data, "timestamp": time.time()}',
      '        await self.redis.xadd(f"stream:{stream_id}", event)',
      '',
      '    async def get_events(self, stream_id: str, from_id: str = "0") -> List[Dict]:',
      '        events = await self.redis.xrange(f"stream:{stream_id}", min=from_id)',
      '        return [{"id": event_id, **fields} for event_id, fields in events]',
      '',
      'class PaymentSaga:',
      '    def __init__(self, event_store: EventStore, stripe_client):',
      '        self.event_store = event_store',
      '        self.stripe = stripe_client',
      '        self.steps: List[SagaStep] = []',
      '',
      '    async def reserve_funds(self, payment_id: str, amount: Decimal) -> Dict:',
      '        await self.event_store.append_event(payment_id, "funds_reservation_started", {"amount": str(amount)})',
      '        # Complex fund reservation logic with multi-currency support',
      '        reserve_result = await self._execute_with_retry(self._reserve_funds_impl, payment_id, amount)',
      '        await self.event_store.append_event(payment_id, "funds_reserved", reserve_result)',
      '        return reserve_result',
      '',
      '    async def _reserve_funds_impl(self, payment_id: str, amount: Decimal) -> Dict:',
      '        # Simulate complex fund reservation with currency conversion',
      '        conversion_rate = await self._get_conversion_rate("USD", "EUR")',
      '        reserved_amount = amount * Decimal(str(conversion_rate))',
      '        return {"payment_id": payment_id, "reserved": str(reserved_amount), "rate": conversion_rate}',
      '',
      '    async def _get_conversion_rate(self, from_currency: str, to_currency: str) -> float:',
      '        # Mock complex currency conversion with rate caching',
      '        cache_key = f"rate:{from_currency}:{to_currency}"',
      '        cached_rate = await self.event_store.redis.get(cache_key)',
      '        if cached_rate:',
      '            return float(cached_rate)',
      '        rate = 0.85  # Mock rate',
      '        await self.event_store.redis.setex(cache_key, 300, str(rate))',
      '        return rate',
      '',
      '    async def _execute_with_retry(self, func: Callable, *args, max_retries: int = 3) -> Any:',
      '        for attempt in range(max_retries):',
      '            try:',
      '                return await func(*args)',
      '            except Exception as e:',
      '                if attempt == max_retries - 1:',
      '                    raise e',
      '                await asyncio.sleep(2 ** attempt)',
      '',
      'class PaymentService:',
      '    def __init__(self, db: AsyncSession, redis_client: redis.Redis):',
      '        self.db = db',
      '        self.redis = redis_client',
      '        self.stripe = stripe',
      '        self.stripe.api_key = "sk_test_..."',
      '        self.circuit_breaker = CircuitBreaker()',
      '        self.event_store = EventStore(redis_client)',
      '        self.saga = PaymentSaga(self.event_store, self.stripe)',
      '',
      '    async def process_complex_payment(self, amount: Decimal, currency: str, metadata: Dict) -> Dict:',
      '        payment_id = self._generate_payment_id()',
      '        ',
      '        try:',
      '            # Start distributed transaction saga',
      '            await self.event_store.append_event(payment_id, "payment_initiated", {',
      '                "amount": str(amount), "currency": currency, "metadata": metadata',
      '            })',
      '            ',
      '            # Step 1: Reserve funds with compensation',
      '            reserve_result = await self.saga.reserve_funds(payment_id, amount)',
      '            ',
      '            # Step 2: Create Stripe payment intent with circuit breaker',
      '            intent = await self.circuit_breaker.call(',
      '                self._create_stripe_intent, amount, currency, metadata',
      '            )',
      '            ',
      '            # Step 3: Complex fraud detection',
      '            fraud_score = await self._assess_fraud_risk(metadata, amount)',
      '            if fraud_score > 0.8:',
      '                await self._compensate_reservation(payment_id)',
      '                raise HTTPException(422, "Transaction flagged for fraud")',
      '            ',
      '            await self.event_store.append_event(payment_id, "payment_completed", {',
      '                "intent_id": intent["id"], "fraud_score": fraud_score',
      '            })',
      '            ',
      '            return {"payment_id": payment_id, "client_secret": intent["client_secret"]}',
      '            ',
      '        except Exception as e:',
      '            await self.event_store.append_event(payment_id, "payment_failed", {"error": str(e)})',
      '            await self._execute_saga_compensation(payment_id)',
      '            raise HTTPException(500, f"Payment processing failed: {str(e)}")',
      '',
      '    def _generate_payment_id(self) -> str:',
      '        return hashlib.sha256(f"{time.time()}{asyncio.current_task()}".encode()).hexdigest()[:16]',
    ],
  },

  {
    name: 'asm_processor.cpp',
    language: 'cpp' as const,
    lines: [
      '#include <unordered_map>',
      '#include <vector>',
      '#include <string>',
      '#include <memory>',
      '#include <variant>',
      '#include <optional>',
      '#include <regex>',
      '#include <bitset>',
      '#include <algorithm>',
      '#include <thread>',
      '#include <mutex>',
      '#include <atomic>',
      '',
      'namespace asm_proc {',
      '',
      'enum class OpCode : uint16_t {',
      '    MOV = 0x89, ADD = 0x01, SUB = 0x29, MUL = 0xF7,',
      '    JMP = 0xEB, JZ = 0x74, JNZ = 0x75, CALL = 0xE8,',
      '    RET = 0xC3, PUSH = 0x50, POP = 0x58, NOP = 0x90',
      '};',
      '',
      'enum class RegType : uint8_t {',
      '    EAX = 0, EBX = 1, ECX = 2, EDX = 3,',
      '    ESI = 4, EDI = 5, ESP = 6, EBP = 7',
      '};',
      '',
      'struct Operand {',
      '    enum Type { REG, IMM, MEM } type;',
      '    std::variant<RegType, int32_t, std::pair<RegType, int32_t>> value;',
      '    uint8_t size = 4;',
      '};',
      '',
      'class Instruction {',
      'public:',
      '    OpCode opcode;',
      '    std::vector<Operand> operands;',
      '    std::optional<std::string> label;',
      '    uint32_t address = 0;',
      '    std::bitset<8> flags;',
      '',
      '    bool is_branch() const {',
      '        return opcode == OpCode::JMP || opcode == OpCode::JZ || ',
      '               opcode == OpCode::JNZ || opcode == OpCode::CALL;',
      '    }',
      '',
      '    bool modifies_register(RegType reg) const {',
      '        if (operands.empty()) return false;',
      '        auto& first_op = operands[0];',
      '        return first_op.type == Operand::REG && ',
      '               std::get<RegType>(first_op.value) == reg;',
      '    }',
      '};',
      '',
      'class BasicBlock {',
      'public:',
      '    std::vector<std::unique_ptr<Instruction>> instructions;',
      '    std::vector<BasicBlock*> successors;',
      '    std::vector<BasicBlock*> predecessors;',
      '    std::bitset<8> live_in, live_out;',
      '    uint32_t id;',
      '',
      '    void add_successor(BasicBlock* block) {',
      '        successors.push_back(block);',
      '        block->predecessors.push_back(this);',
      '    }',
      '};',
      '',
      'class RegisterAllocator {',
      'private:',
      '    struct InterferenceGraph {',
      '        std::unordered_map<RegType, std::vector<RegType>> adjacency;',
      '        std::unordered_map<RegType, int> colors;',
      '        ',
      '        void add_edge(RegType u, RegType v) {',
      '            adjacency[u].push_back(v);',
      '            adjacency[v].push_back(u);',
      '        }',
      '        ',
      '        bool color_graph(int num_colors) {',
      '            std::vector<RegType> vertices;',
      '            for (auto& [reg, _] : adjacency) vertices.push_back(reg);',
      '            ',
      '            std::sort(vertices.begin(), vertices.end(), [&](RegType a, RegType b) {',
      '                return adjacency[a].size() > adjacency[b].size();',
      '            });',
      '            ',
      '            for (RegType reg : vertices) {',
      '                std::bitset<8> used_colors;',
      '                for (RegType neighbor : adjacency[reg]) {',
      '                    if (colors.count(neighbor)) {',
      '                        used_colors.set(colors[neighbor]);',
      '                    }',
      '                }',
      '                ',
      '                for (int color = 0; color < num_colors; ++color) {',
      '                    if (!used_colors[color]) {',
      '                        colors[reg] = color;',
      '                        break;',
      '                    }',
      '                }',
      '                ',
      '                if (!colors.count(reg)) return false;',
      '            }',
      '            return true;',
      '        }',
      '    };',
      '',
      'public:',
      '    std::unordered_map<RegType, RegType> allocate_registers(',
      '        const std::vector<BasicBlock*>& blocks) {',
      '        ',
      '        InterferenceGraph graph;',
      '        ',
      '        // Build interference graph through liveness analysis',
      '        for (auto* block : blocks) {',
      '            std::bitset<8> live = block->live_out;',
      '            ',
      '            for (auto it = block->instructions.rbegin(); ',
      '                 it != block->instructions.rend(); ++it) {',
      '                auto& inst = **it;',
      '                ',
      '                // Add interference edges for simultaneously live registers',
      '                for (int i = 0; i < 8; ++i) {',
      '                    if (!live[i]) continue;',
      '                    for (int j = i + 1; j < 8; ++j) {',
      '                        if (live[j]) {',
      '                            graph.add_edge(static_cast<RegType>(i), ',
      '                                          static_cast<RegType>(j));',
      '                        }',
      '                    }',
      '                }',
      '            }',
      '        }',
      '        ',
      '        graph.color_graph(8);',
      '        ',
      '        std::unordered_map<RegType, RegType> allocation;',
      '        for (auto& [reg, color] : graph.colors) {',
      '            allocation[reg] = static_cast<RegType>(color);',
      '        }',
      '        ',
      '        return allocation;',
      '    }',
      '};',
      '',
      'class AssemblerProcessor {',
      'private:',
      '    std::unordered_map<std::string, OpCode> opcode_map;',
      '    std::unordered_map<std::string, RegType> register_map;',
      '    std::vector<BasicBlock*> basic_blocks;',
      '    RegisterAllocator allocator;',
      '    std::mutex processing_mutex;',
      '',
      '    void initialize_maps() {',
      '        opcode_map = {{"mov", OpCode::MOV}, {"add", OpCode::ADD}, ',
      '                     {"sub", OpCode::SUB}, {"jmp", OpCode::JMP}};',
      '        register_map = {{"eax", RegType::EAX}, {"ebx", RegType::EBX},',
      '                       {"ecx", RegType::ECX}, {"edx", RegType::EDX}};',
      '    }',
      '',
      'public:',
      '    AssemblerProcessor() { initialize_maps(); }',
      '',
      '    std::vector<uint8_t> process_assembly(const std::string& asm_code) {',
      '        std::lock_guard<std::mutex> lock(processing_mutex);',
      '        ',
      '        auto instructions = parse_instructions(asm_code);',
      '        auto blocks = build_control_flow_graph(instructions);',
      '        perform_optimizations(blocks);',
      '        auto allocation = allocator.allocate_registers(blocks);',
      '        ',
      '        return generate_machine_code(blocks, allocation);',
      '    }',
      '};',
      '',
      '} // namespace asm_proc',
    ],
  },
];